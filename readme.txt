    socks 代理

    http://www.ietf.org/rfc/rfc1928.txt
    http://www.ietf.org/rfc/rfc1929.txt
    https://my.oschina.net/u/660063/blog/201187

    控制服务器和手机端使用基于 socks5 协议的通信，考虑到实际需要，修改通信过程如下：
    1.连接到控制服务器使用标准的认证过程，选择私有方法 80，如果不支持则返回无可选然后关闭
    2.手机端接收到80后，发送一个 json 数据 {imsi: xx, sysver: xx}，格式如下：
           +----+----------+----------+
           |VER | DLEN     | DATA    |
           +----+----------+----------+
           | 1  |    2     | 1-4096  |
           +----+----------+----------+
    在 data 里发送 json 格式的如下数据： {'imsi':xx, 'sysver':xx}，如果不符合此格式则表示可能是别人冒充的，直接关闭连接
    否则记录手机端注册成功，返回 b'\x05\x00'
    3.注册成功后，手机端等待数据，接收到的数据格式只有一种，如下：
        +----+-----+-------+------+----------+----------+
        |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT | DATA
        +----+-----+-------+------+----------+----------+
        | 1  |  1  | 1     |  1   | Variable |    2     | -
        +----+-----+-------+------+----------+----------+
        CMD 会是 \x81 表示是转发的数据包，\x82 表示是心跳包，不用处理
        rsv 会是 表示客户端编号
        atyp 表示地址类型，
        dst_addr 是标准的socks5地址，dst_port是端口
        之后的全部是需要转发的数据，直接转发到 dst_addr:dst_port
        在接收到回复之后，回复给服务器，数据格式是
        VER     CMD     RSV   ATP   DLEN    DATA
        1       1       1     1      2       -
        VER 05
        CMD 80
        RSV 是 用户编号，一个连接必须有独特的编号，一旦编号确定了，不能再更改目的地址；用户使用标准 sock5 的认证登陆方式
            连接时会确定该连接的 rsv，由于一个标准的 socks5 连接只会有一个目的地且不会更改，所以可以保证地址是不会变的，
            可知用户可以同时与多个地址通过代理发送数据

        手机端返回
        +----+-----+-------+--------+
        |VER | CMD |  RSV  | STATUS | DLEN  DATA
        +----+-----+-------+--------+
        | 1  |  1  |  1    |   1    |   2    -
        +----+-----+-------+--------+

        可知有一个问题，如果某个用户使用了 rsv = 1 向目的地址 A 建立连接并发出了请求但是立即关闭了；
        这时候另一个用户再次使用 rsv = 1 向目的地址 A 建立连接并发出请求，代理端无法判断这不是同一个用户；
        暂不考虑这种异常



    控制服务器在登记了手机端之后，由单独的线程逐一检查，发现有 uptime 已经超过了 30s 就发送一个心跳包来确认手机端
    是否还连接着，发送失败则关闭套接字并从数组中移出；
    把发送和接收消息封装起来，每次接收或发送数据时更新 uptime


    允许不同 socks 方式连接，如果是认证方式的，则是管理员；如果是私有方法的，则是手机端代理；
    有一个管理员登陆的话，就建立一个单独的线程，线程中 select 该管理员的 socket 和对应的代理 socket，互相转发数据；


    接收到请求时，如果是 method = \x80，那么是手机端代理，加入到代理列表，通过定期 keepalive 保持连接；
    如果 method = 2 ，那么是用户，使用单独线程，与对应的代理连接一起 select


    把所有代理的套接字用单独的线程 select，可读时就判断是否有对端，有的话就根据 rsv 写入，注意需要自己组包
    支持并发， 因为同一个用户登陆都是使用相同代理地址，所以不用自然会把所有数据都经由相同代理发送

